/*
 分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。
 
 输入格式：
 
 输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。
 
 提示：在scanf的格式字符串中加入/，让scanf来处理这个斜杠。
 
 输出格式：
 
 在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如 5/6表示6分之5。
 
 输入样例：
 
 60/120
 输出样例：
 
 1/2
 */

/*
 辗转相除法算法描述
 计算过程
 辗转相除法是一种递归算法，每一步计算的输出值就是下一步计算时的输入值。设k表示步骤数（从0开始计数），算法的计算过程如下。
 
 每一步的输入是都是前两次计算的非负余数rk−1和rk−2。因为每一步计算出的余数都在不断减小，所以，rk−1小于rk−2。在第k步中，算法计算出满足以下等式的商qk和余数 rk：
 
 rk−2 = qk rk−1 + rk
 其中0 ≤ rk < rk−1。也就是rk−2要不断减去rk−1直到比rk−1小。
 
 为求简明，以下只说明如何求两个非负整数a和b的最大公约数（负数的情况是简单的）。在第一步计算时（k = 0），设r−2和r−1分别等于a和b，第2步（此时k = 1）时计算r−1（即b）和r0（第一步计算产生的余数）相除产生的商和余数，以此类推。整个算法可以用如下等式表示：
 
 a = q0 b + r0
 b = q1 r0 + r1
 r0 = q2 r1 + r2
 r1 = q3 r2 + r3
 …
 如果有a < b，算法的第一步实际上会把两个数字交换，因为这时a除以b所得的商q0会等于0，余数r0则等于a。然后，算法的第二步便是把b除以a，再计算所得之商和余数。所以，对于k ≥ 0总有rk<rk−1，即运算的每一步中得出的余数一定小于上一步计算的余数。
 
 由于每一步的余数都在减小并且不为负数，必然存在第N步时rN等于0，使算法终止，rN−1就是a和b的最大公约数。其中N不可能无穷大，因为在r0和0之间只有有限个自然数。
 */
#include <stdio.h>
int GCD(int a, int b) // 辗转相除法
{
    int R;
    do
    {
        R = a % b;
        a = b; // 上一次的余数
        b = R; // 当前的余数
    } while (R != 0);
    return a;
}
int main()
{
    int a, b, c;
    scanf("%d/%d", &a, &b);
    c = GCD(a, b);
    printf("%d/%d", a/c, b/c);
    return 0;
}